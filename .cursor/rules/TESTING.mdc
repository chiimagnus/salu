### Salu 测试技术文档（XCTest / CLI UI Tests / Coverage）

本文件用于说明本仓库的测试分层、组织方式、运行方式、覆盖率与 CI 策略，以及当测试失败时如何判断是“测试代码问题”还是“项目代码问题”。

---

### 1) 测试分层（为什么要分这么多测试文件/Target）

本仓库分成三层测试（每层解决的问题不同）：

- **GameCoreTests（白盒单元/集成级逻辑测试）**
  - 覆盖 `Sources/GameCore` 的纯逻辑：战斗引擎、伤害/格挡计算、状态、地图生成、奖励、注册表等。
  - 优点：快、稳定、定位精确（失败基本就是逻辑回归）。

- **GameCLITests（GameCLI 白盒单元测试）**
  - 覆盖 `Sources/GameCLI` 中可注入的“业务服务层”逻辑：`SaveService` / `HistoryService` 等。
  - 这层不跑子进程，不依赖 stdout/stderr，不依赖真实文件 I/O（用 in-memory fake store），所以稳定且断言强。

- **GameCLIUITests（黑盒 CLI「UI」测试）**
  - 使用 `Foundation.Process` 启动 `GameCLI` 可执行文件，通过 stdin 驱动流程，并对 stdout/文件副作用做断言。
  - 目的：验证“可执行文件真的能跑 + 菜单/流程真的可达 + 关键落盘真的发生”，避免 CI 假绿（只编译通过但运行即挂）。

**为什么文件看起来多？**

- 测试文件和源代码一样，需要**单一职责**。将不同领域拆到不同文件里，能避免单个测试文件无限膨胀（可读性下降、冲突概率上升、维护成本更高）。
- 本仓库按领域拆分源代码（Battle/Cards/Status/Map/Run/CLI Screens/Rooms/Persistence），测试按同样方式拆分是最自然、也最易维护的结构。

**结论**：文件数量多不等于复杂；“一个文件一件事”反而更容易长期维护。若你偏好更少文件，我们也可以合并，但会牺牲可读性与协作冲突概率。

---

### 2) 如何运行测试（本地/CI 一致）

- **运行所有 Swift 测试（推荐）**

```bash
swift test
```

这会运行所有 test target（当前包括 `GameCoreTests`、`GameCLITests`、`GameCLIUITests`）。

- **只跑某个 target / 用例（定位失败时用）**

```bash
swift test --filter GameCoreTests
swift test --filter GameCLITests
swift test --filter GameCLIUITests
swift test --filter GameCLIUITests.GameCLIHelpUITests/testBattleHelp_canOpenAndReturn
```

- **生成覆盖率（CI 与本地一致）**

```bash
swift test --enable-code-coverage
```

覆盖率产物在 `.build/**/debug/codecov/`，常见文件：
- `default.profdata`
- `Salu.json`

---

### 3) CLI UI tests 的稳定化机制（SALU_TEST_MODE / SALU_DATA_DIR）

CLI UI tests 的核心难点是：随机性与流程过长会导致测试慢/不稳定。因此我们使用两类环境变量：

- **SALU_DATA_DIR**
  - 目的：把存档/战绩写到测试临时目录，避免污染真实用户数据，且测试之间互不干扰。
  - UI tests 会用 `TemporaryDirectory()` 创建一个临时目录，并设置 `SALU_DATA_DIR` 指向该目录。

- **SALU_TEST_MODE=1**
  - 目的：让 UI tests 更快、更确定（例如战斗压缩为极低 HP 敌人 + 极小牌组）。
  - 约定：大多数 UI tests 都设置 `SALU_TEST_MODE=1`；另外保留少量 real-mode smoke tests（不设 test mode）只验证“不崩/不挂死”。

---

### 4) UI tests 使用哪个 GameCLI 可执行文件（覆盖率关键）

`Tests/GameCLIUITests/Support/CLIRunner.swift` 的默认策略：

- **默认优先使用 `.build/debug/GameCLI`**（更利于调试 + 覆盖率统计）
- 仅当 debug 不存在时才回退到 `.build/release/GameCLI`
- 如需显式指定可执行文件，可使用：
  - `SALU_CLI_BINARY_PATH=/path/to/GameCLI`

这条规则非常重要：如果 UI tests 运行的是 release binary，覆盖率通常会缺失（CI 会看起来“GameCLI 覆盖率为 0”）。

---

### 5) 如何看覆盖率（本地手工查看）

示例（macOS）：

```bash
xcrun llvm-cov report \
  .build/debug/SaluPackageTests.xctest/Contents/MacOS/SaluPackageTests \
  --instr-profile=.build/arm64-apple-macosx/debug/codecov/default.profdata \
  --ignore-filename-regex "Tests|test"
```

你最关心的是最后的 `TOTAL` 行：
- **Lines Cover**（行覆盖率）
- **Functions Cover**（函数覆盖率）

覆盖率的作用不是“追求 100%”，而是用来快速定位“我们完全没测到哪一块”。

---

### 6) 测试失败时，怎么判断是测试代码问题还是项目代码问题？

按失败类型分：

- **编译失败（compile error）**
  - 99% 是代码改动导致的真实问题（源代码或测试代码都可能）。
  - 做法：看报错文件路径；如果报在 `Tests/`，优先修测试；如果报在 `Sources/`，优先修业务代码。

- **断言失败（XCTAssert… failed）**
  - 先看断言的“意图”是否正确：
    - 如果断言本身错（例如期待的文案/数值写错）→ 测试代码问题
    - 如果断言正确但实际行为变了 → 业务代码回归（或需求变更未同步更新测试）
  - 建议：用 `swift test --filter ...` 单跑该用例，减少噪音。

- **超时（timedOut / 卡死）**
  - 通常是 UI 测试流程没有走到退出条件（stdin 不够/进入了等待输入的界面）。
  - 做法：
    - 先看 `CLIRunnerError.timedOut` 输出的 partial stdout/stderr，确认卡在哪个界面
    - 再补齐输入序列或修复业务代码的“等待输入”路径

---

### 7) 新增测试的推荐写法（保持可维护性）

- **按领域建文件**
  - 例如：卡牌纯函数测试放 `CardDefinitionPlayTests.swift`
  - BattleEngine 分支放 `BattleEngineFlowTests.swift`
  - CLI 的设置菜单 UI 测试放 `GameCLISettingsUITests.swift`

- **每个 test 必须写清楚“目的”**
  - 文件级 doc comment：为什么需要这类测试、要防什么回归
  - 用例级 doc comment：测哪个分支/场景

- **断言优先级**
  - GameCore：尽量断言结构化状态（HP、block、status stacks、events）
  - GameCLI：优先断言落盘 JSON 可解码 + 关键字段；stdout 只做“关键文案存在”的轻断言

---

### 8) CI 策略（确保每次都跑全量）

当前 CI（`.github/workflows/test.yml`）会：
- `swift build`（debug）
- `swift build -c release`（确保 release 也能编译）
- `swift test --enable-code-coverage`（全量测试 + 覆盖率）
- 输出 `llvm-cov report` 的摘要到日志（方便 PR 快速判断覆盖率变化）
- 上传 coverage artifacts（`default.profdata` / `Salu.json`）

